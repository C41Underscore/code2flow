#!/usr/bin/python
'''
Usage:
javascript2dot.py file.js
Then, with graphviz, open out.gv

* Green means leaf function (the function calls no other functions)
* Brown means trunk function (the function is called by no other function)
* Inverted arrow means that the called function returns something (it might just be a boolean though)

Group is the namespace
group will contain function nodes and possibly subgroups
There will be one global group to hold everything
In javascript, this is the window namespace which is also implicit
it must hold all of the nodes in its space
we will loop through the group to calculate edges and this will be a convenient way to determine namespace of the edges
They must maintain an internal representation of content for determining edges. Even subgroups should contain this. It makes things easier

Nodes are functions
node will contain a parent pointer to the namespace
Should also have an internal filestring of the content

Edges are function calls


This python file is a wrapper for the functionality. Basically, it will:
1. parse arguments
2. read the files
3. decide which implementation (javascript or python) to use
4. import that and run the mapper for that implementation
5. write the dot file

'''

import argparse
import logging
import os

import lib.dotgenerator as dotgenerator
import lib.engine as engine
import lib.languages.python as python_implementation
# import lib.languages.javascript as js_implementation

DESCRIPTION = "Generate flow charts from your source code."
LANGUAGES = {
    # 'js': js_implementation,
    'py': python_implementation
}

logging.basicConfig(format="Code2Flow: %(message)s", level=logging.INFO)


def is_exe(fpath):
    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)


def is_installed(program):
    for path in os.environ["PATH"].split(os.pathsep):
        path = path.strip('"')
        exe_file = os.path.join(path, program)
        if is_exe(exe_file):
            return True

    return False


def get_sources_and_language(raw_sources, language):
    individual_files = []
    for source in raw_sources:
        if os.path.isfile(source):
            individual_files.append(source)
            continue
        for root, _, files in os.walk(source):
            for f in files:
                individual_files.append(os.path.join(root, f))

    if not individual_files:
        raise Exception("No source files found from %r" % raw_sources)

    if not language:
        for source in individual_files:
            suffix = source.rsplit('.', 1)[-1]
            if suffix in LANGUAGES:
                language = suffix
                break
        else:
            raise Exception("Language could not be determined from source files %r." % raw_sources)

    sources = set()
    for source in individual_files:
        if source.endswith('.' + language):
            sources.add(source)

    if not sources:
        logging.info("Could not find any source files given %r and language %r" % (raw_sources, language))

    logging.info("Processing %d source file(s):" % (len(sources)))
    for source in sources:
        logging.info("  " + source)
    ignored_files = set(sources) - set(individual_files)
    if ignored_files:
        logging.info("(%d file(s) were discarded %r)" % (len(ignored_files), ignored_files))

    return sources, language


def code2flow(raw_sources, output_file, language, hide_legend, quiet):
    """
    Top-level function. Generate a diagram based on source code.
    Can generate either a dotfile or an image.

    :param list[str] raw_sources: file or directory paths
    :param str output_file: path to the output file. SVG/PNG will generate an image.
    :param bool hide_legend: Omit the legend from the output
    :param bool quiet:

    :rtype: None
    """

    if quiet:
        logging.setLevel(logging.WARNING)

    sources, language = get_sources_and_language(raw_sources, language)

    # determine whether we are just writing a dot file or also translating to an image
    if output_file.endswith('.gv') or output_file.endswith('.dot'):
        dot_file = output_file
        final_file = None
    else:
        if not is_installed('dot') and not is_installed('dot.exe'):
            raise Exception(
                "Can't generate a flowchart image because neither `dot` nor "
                "`dot.exe` was found. Either install graphviz (see the README) "
                "or set your --output argument to a dotfile like out.dot or out.gz.")
        final_file = output_file
        dot_file, extension = output_file.rsplit('.', 1)
        dot_file += '.gv'

    lang = LANGUAGES[language].Lang

    # Do the mapping (where the magic happens)
    groups, nodes, edges = engine.map_it(lang, sources)

    dotgenerator.write_dot_file(dot_file=dot_file, nodes=nodes, edges=edges, groups=groups, hide_legend=args.hide_legend)

    # translate to an image if that was requested
    if final_file:
        command = "dot -T%s %s > %s" % (extension, dot_file, final_file)
        os.system(command)

    logging.info("Completed your flowchart!")
    logging.info(f"To see it, open {output_file}.")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=DESCRIPTION,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        'sources', metavar='sources', nargs='+',
        help='Source code file/directory paths.')
    parser.add_argument(
        '--output', '-o', default='out.png',
        help='Output path. Supported types are {dot, gv, png, svg}.'
             'If you ',)
    parser.add_argument(
        '--language', choices=['py', 'js'],
        help='Process this language and ignore all other files.'
             'If omitted, use the suffix of the first source file.')
    parser.add_argument(
        '--hide-legend', action='store_true',
        help='By default, Code2flow generates a small legend. This flag hides it.')
    parser.add_argument(
        '--quiet', '-q', action='store_true')
    parser.add_argument(
        '--version', action='version', version='%(prog)s 0.3')  # TODO2021 what is this

    args = parser.parse_args()

    code2flow(args.sources, args.output, args.language, args.hide_legend, args.quiet)
