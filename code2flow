#!/usr/bin/env python3

'''

'''

import argparse
import logging
import os

import lib.dotgenerator as dotgenerator
import lib.engine as engine
from lib.languages.python import Python
# from lib.languages.javascript import Javascript

# import lib.languages.javascript as js_implementation

DESCRIPTION = "Generate flow charts from your source code. " \
              "See the README at https://github.com/scottrogowski/code2flow."
LANGUAGES = {
    # 'js': Javascript,
    'py': Python
}
VALID_EXTENSIONS = {'.png', '.svg', '.dot', '.gv'}


def is_installed(executable_cmd):
    """
    Determine whether a command can be run or not

    :param list[str] individual_files:
    :rtype: str
    """
    for path in os.environ["PATH"].split(os.pathsep):
        path = path.strip('"')
        exe_file = os.path.join(path, executable_cmd)
        if os.path.isfile(exe_file) and os.access(exe_file, os.X_OK):
            return True
    return False


def determine_language(individual_files):
    """
    Given a list of filepaths, determine the language from the first
    valid extension

    :param list[str] individual_files:
    :rtype: str
    """
    for source, _ in individual_files:
        suffix = source.rsplit('.', 1)[-1]
        if suffix in LANGUAGES:
            logging.info("Implicitly detected language as %r.", suffix)
            return suffix
    raise Exception(f"Language could not be detected from input {individual_files}. ",
                    "Try explicitly passing the language flag.")


def get_sources_and_language(raw_sources, language):
    """
    Given a list of files and directories, return just files.
    If we are not passed a language, determine it.
    Filter out files that are not of that language

    :param list[str] raw_sources: file or directory paths
    :param str|None language: Input language
    :rtype: (list, str)
    """
    individual_files = []
    for source in sorted(raw_sources):
        if os.path.isfile(source):
            individual_files.append((source, True))
            continue
        for root, _, files in os.walk(source):
            for f in files:
                individual_files.append((os.path.join(root, f), False))

    if not individual_files:
        raise Exception("No source files found from %r" % raw_sources)
    logging.info("Found %d files from sources argument.", len(individual_files))

    if not language:
        language = determine_language(individual_files)

    sources = set()
    for source, explicity_added in individual_files:
        if explicity_added or source.endswith('.' + language):
            sources.add(source)
        else:
            logging.info("Skipping %r which is not a %s file. "
                         "If this is incorrect, include it explicitly.",
                         source, language)

    if not sources:
        raise Exception("Could not find any source files given {raw_sources} "
                        "and language {language}")

    sources = sorted(list(sources))
    logging.warning("Processing %d source file(s)." % (len(sources)))
    for source in sources:
        logging.info("  " + source)

    return sources, language


def code2flow(raw_sources, output_filename, language, hide_legend,
              exclude_namespaces, exclude_functions,
              no_grouping, no_trimming, quiet):
    """
    Top-level function. Generate a diagram based on source code.
    Can generate either a dotfile or an image.

    :param list[str] raw_sources: file or directory paths
    :param str output_filename: path to the output file. SVG/PNG will generate an image.
    :param str language: input language extension
    :param bool hide_legend: Omit the legend from the output
    :param str exclude_namespaces: Comma separated list of namespaces to exclude
    :param str exclude_functions: Comma separated list of functions to exclude
    :param bool no_grouping: Don't group functions into namespaces in the final output
    :param bool no_trimming: Don't trim orphaned functions / namespaces
    :param bool quiet: less logging
    :rtype: None
    """

    if quiet:
        logging.basicConfig(format="Code2Flow: %(message)s", level=logging.WARNING)
    else:
        logging.basicConfig(format="Code2Flow: %(message)s", level=logging.INFO)

    sources, language = get_sources_and_language(raw_sources, language)

    if not any(output_filename.endswith(ext) for ext in VALID_EXTENSIONS):
        raise Exception("Output filename must end in one of: %r" % VALID_EXTENSIONS)

    final_img_filename = None
    if output_filename.endswith('.png') or output_filename.endswith('.svg'):
        if not is_installed('dot') and not is_installed('dot.exe'):
            raise Exception(
                "Can't generate a flowchart image because neither `dot` nor "
                "`dot.exe` was found. Either install graphviz (see the README) "
                "or set your --output argument to a 'dot' filename like out.dot "
                "or out.gz.")
        final_img_filename = output_filename
        output_filename, extension = output_filename.rsplit('.', 1)
        output_filename += '.gv'

    lang = LANGUAGES[language]

    # Do the mapping (where the magic happens)
    groups, nodes, edges = engine.map_it(lang, sources, no_trimming,
                                         exclude_namespaces, exclude_functions)

    logging.info("Generating dot file...")
    dotgenerator.write_dot_file(output_filename, nodes=nodes, edges=edges,
                                groups=groups, hide_legend=hide_legend,
                                no_grouping=no_grouping)

    # translate to an image if that was requested
    if final_img_filename:
        command = "dot -T%s %s > %s" % (extension, output_filename, final_img_filename)
        os.system(command)

    logging.warning("Completed your flowchart! To see it, open %r.",
                    final_img_filename or output_filename)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=DESCRIPTION,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        'sources', metavar='sources', nargs='+',
        help='source code file/directory paths.')
    parser.add_argument(
        '--output', '-o', default='out.png',
        help=f'output file path. Supported types are {VALID_EXTENSIONS}.')
    parser.add_argument(
        '--language', choices=['py', 'js'],
        help='process this language and ignore all other files.'
             'If omitted, use the suffix of the first source file.')
    parser.add_argument(
        '--exclude-functions',
        help='exclude functions from the output. Comma delimited.')
    parser.add_argument(
        '--exclude-namespaces',
        help='exclude namespaces (Classes, modules, etc) from the output. Comma delimited.')
    parser.add_argument(
        '--no-grouping', action='store_true',
        help='instead of grouping functions into namespaces, let functions float.')
    parser.add_argument(
        '--no-trimming', action='store_true',
        help='show all functions/namespaces whether or not they connect to anything.')
    parser.add_argument(
        '--hide-legend', action='store_true',
        help='by default, Code2flow generates a small legend. This flag hides it.')
    parser.add_argument(
        '--quiet', '-q', action='store_true',
        help='suppress most logging')
    parser.add_argument(
        '--version', action='version', version='%(prog)s 0.3')  # TODO2021 what is this

    args = parser.parse_args()

    code2flow(args.sources, args.output, args.language, args.hide_legend,
              args.exclude_namespaces, args.exclude_functions,
              args.no_grouping, args.no_trimming, args.quiet)
